module typechecking/typescript

imports

  signatures/-
  typechecking/-
  
signature
    
    
    constructors
    	RECORD	: scope -> Type
    	
    	NUMBER	: Type
		  STRING	: Type
		  BOOLEAN : Type
		  VOID    : Type
		  FUNCTION: list(Type) * Type -> Type
		

	name resolution
		labels
	      P I
	
	    order
	      D < I,
	      D < P,
	      I < P
	
	    well-formedness
	      P* . I*
      
		namespaces
			Field
			Type
			Value
      
rules
	
	init ^ (s) :=
    	new s.
    
    [[ Program(statements) ^ (s) ]] :=
    	Map1 [[ statements ^ (s) ]],
    	distinct/name D(s)/Value | error @ NAMES,
    	distinct/name D(s)/Type | error @ NAMES.
    	
    	
    [[ InterfaceDecl(name, _, fields) ^ (s) ]] :=
    	Type{name} <- s,
    	Type{name} : ty !,
    	[[ fields ^ (s): ty ]].
    
    [[ ObjectType(fields) ^ (s): ty ]] :=
    	new record_scope,
    	ty == RECORD(record_scope),
    	record_scope -P-> s,
    	distinct/name D(record_scope)/Field | error $[Duplicate declaration of field] @ NAMES,
    	Map1 [[ fields ^ (record_scope) ]].
    
    [[ TypeMember(name, _, None()) ^ (s) ]] := false.
    
   	[[ TypeMember(name, _, Some(type)) ^ (s) ]] :=
   		Field{name} <- s,
   		Field{name} : ty !,
   		[[ type ^ (s): ty]].
   	
   	[[ TypeAnnotation(Number()) ^(_): NUMBER()]] := true.
   	[[ TypeAnnotation(String()) ^(_): STRING()]] := true.
   	
   	[[ TypeAnnotation(Object(objectType)) ^ (s): ty ]] :=
   	  [[ objectType ^ (s) : ty ]].
    	
    [[ TypeAnnotation(Id(name)) ^ (s): ty ]] :=
    	Type{name} -> s,
    	Type{name} |-> d | error $[Cannot resolve [name]],
        d : ty.
    	
    [[ Lexical(_, declarations, _) ^ (s) ]] :=
    	Map1 [[ declarations ^ (s) ]].
    
    [[ Variable(declarations, _) ^ (s) ]] :=
      Map1 [[ declarations ^ (s) ]].
    
    [[ SimpleVariableDeclaration(name, None(), Some(value)) ^ (s) ]] := 
      [[ value ^ (s) : valueTy ]],
      Value{name} <- s,
      Value{name} : valueTy,
      valueTy != VOID().

    [[ SimpleVariableDeclaration(name, Some(type), None()) ^ (s) ]] :=
    	Value{name} <- s,
    	Value{name} : ty !,
    	[[ type ^ (s) : ty ]].

    [[ SimpleVariableDeclaration(name, Some(type), Some(value)) ^ (s) ]] :=
    	Value{name} <- s,
    	Value{name} : ty !,
    	[[ type ^ (s) : ty ]],
    	[[ value ^ (s) : valueTy ]],
    	ty <? valueTy.
    
    [[ PAIR(NUMBER(), NUMBER()) ^(_) ]] := true.
    [[ PAIR(STRING(), STRING()) ^(_) ]] := true.
    
    [[ PAIR(one, other) ^ (s) ]] :=
    	one == RECORD(one_scope) | error $[object type expected],
    	other == RECORD(other_scope) | error $[object type expected].
    
    [[ Number(_) ^ (_): NUMBER() ]] := true.
    [[ String(_) ^ (_): STRING() ]] := true.
    [[ True() ^ (_): BOOLEAN() ]] := true.
    [[ False() ^ (_): BOOLEAN() ]] := true.
    
    [[ Expression(expression, _) ^ (s) ]] :=
      [[ expression ^ (s): ty ]].
    
    [[ Id(name) ^ (s) : ty ]] :=
      Value{name} -> s,
      Value{name} |-> d | error $[Cannot resolve [name]],
        d : ty.
    
    [[ Function(Some(name), CallSignature(_, Some(parameters), None()), body) ^ (s) ]] :=
      new function_scope,
      Value{name} <- s,
      Value{name} : FUNCTION(paramsTy, VOID()) !,
      [[ parameters ^ (s, function_scope): paramsTy ]],
      [[ returnType ^ (s) : ty ]],
      Map1T [[ body ^ (function_scope): bodyType ]].
    
    [[ Function(Some(name), CallSignature(_, Some(parameters), Some(returnType)), body) ^ (s) ]] :=
      new function_scope,
      Value{name} <- s,
      Value{name} : FUNCTION(paramsTy, ty) !,
      [[ parameters ^ (s, function_scope): paramsTy ]],
      [[ returnType ^ (s) : ty ]],
      Map1T [[ body ^ (function_scope): bodyType ]].
     
    [[ RequiredParameterList(parameters) ^ (s, function_scope) : ty ]] :=
      Map2T [[ parameters ^ (s, function_scope): ty ]].
    
    [[ RequiredParameter(name, None()) ^ (s, function_scope) : ty ]] := false.
     
    [[ RequiredParameter(name, Some(type)) ^ (s, function_scope) : ty ]] :=
      Value{name} <- function_scope,
      Value{name} : ty !,
      [[ type ^ (s) : ty ]].
    
    [[ ValueReturn(value, _) ^ (s) : ty ]] :=
      [[ value ^ (s) : ty ]].
    
    [[ Call(function, arguments) ^ (s) : ty ]] :=
      [[ function ^ (s) : functionTy ]],
      functionTy == FUNCTION(paramsTy, ty),
      Map1T [[ arguments ^ (s): argsTy ]],
      argsTy <? paramsTy.
    	
    	
    	
    	