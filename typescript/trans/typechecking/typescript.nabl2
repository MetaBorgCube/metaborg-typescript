module typechecking/typescript

imports

  signatures/-
  typechecking/-
  
signature

	constraint generator
		Map3	[[ list(a) ^ (b,c,d) ]]
		Map3(X)	[[ list(a) ^ (b,c,d) ]]
    
    
    constructors
    	RECORD	: scope -> Type
    	MODULE  : scope -> Type
    	
    	NUMBER	  : Type
		  STRING	  : Type
		  BOOLEAN   : Type
		  UNDEFINED : Type
		  FUNCTION  : list(Type) * Type -> Type
		  MODULE	: occurrence -> Type
		

	name resolution
		labels
	      P I
	      
	    order
	      D < I,
	      D < P,
	      I < P
	
	    well-formedness
	      P* . I*
      
		namespaces
			Field
			Type
			Value
			Return
      
rules

	Map3	[[ xs ^ (b,c,d) ]] := Map3(default) [[ xs ^ (b,c,d) ]].
	Map3(X)	[[ [x|xs] ^ (s1,s2,s3) ]] :=
	    X[[ x ^ (s1,s2,s3) ]],
	    Map3(X)[[ xs ^ (s1,s2,s3) ]].
	Map3(X)[[ [] ^ (s1,s2,s3) ]].
	
	init ^ (s) :=
    	new s.
    
    [[ Program(statements) ^ (s) ]] :=
      new program_scope,
      program_scope -P-> s,
    	Map1 [[ statements ^ (program_scope) ]],
    	distinct/name D(program_scope)/Value | error @ NAMES,
    	distinct/name D(program_scope)/Type | error @ NAMES.
    
    [[ Module(name, body) ^ (s) ]] :=
      new module_scope,
      new statement_scope,
      new export_scope,
      module_scope -I-> export_scope,
      module_scope -P-> s,
      statement_scope -P-> module_scope,
      export_scope -P-> statement_scope,
      Module{name} <- s,
      Module{name} ===> module_scope,
      Module{name} : moduleType,
      moduleType == MODULE(Module{name}),
      Map3 [[ body ^ (module_scope, export_scope, statement_scope) ]],
      distinct/name (D(statement_scope)/Value union D(export_scope)/Value) | error @ NAMES,
      distinct/name (D(statement_scope)/Type union D(export_scope)/Type) | error @ NAMES.
      
    [[ ExportDeclaration(declaration) ^ (module_scope, export_scope, statement_scope) ]] :=
      [[ declaration ^ (export_scope) ]].
    
    [[ ModuleStatement(statement) ^ (module_scope, export_scope, statement_scope) ]] :=
      [[ statement ^ (statement_scope) ]].
    
    [[ ImportClause(imports, From(filename), _) ^ (module_scope, export_scope, statement_scope) ]] :=
      Module{filename} -> module_scope,
      Module{filename} |-> d | error $[Could not find module [filename]],
      d : ty,
      ty == MODULE(m),
      m ?===> imported_module_scope,
      new import_scope,
      import_scope -P-> imported_module_scope,
      [[ imports ^ (import_scope, statement_scope) ]].
    
    [[ ImportsList(list, _) ^ (import_scope, statement_scope) ]] :=
      Map2 [[ list ^ (import_scope, statement_scope) ]].
    
    [[ NamedImport(name) ^ (import_scope, statement_scope) ]] :=
      Value{name} -> import_scope,
      Value{name} |-> d | error $[Could not find exported value [name].],
      d: ty,
      Value{name} <- statement_scope,
      Value{name} : ty !.
    	
    [[ InterfaceDecl(name, _, fields) ^ (s) ]] :=
    	Type{name} <- s,
    	Type{name} : ty !,
    	[[ fields ^ (s): ty ]].
    
    [[ ObjectType(fields) ^ (s): ty ]] :=
    	new record_scope,
    	ty == RECORD(record_scope),
    	record_scope -P-> s,
    	distinct/name D(record_scope)/Field | error $[Duplicate declaration of field] @ NAMES,
    	Map1 [[ fields ^ (record_scope) ]].
    
    [[ TypeMember(name, _, None()) ^ (s) ]] := false.
    
   	[[ TypeMember(name, _, Some(type)) ^ (s) ]] :=
   		Field{name} <- s,
   		Field{name} : ty !,
   		[[ type ^ (s): ty]].
   	
   	[[ TypeAnnotation(Number()) ^(_): NUMBER()]] := true.
   	[[ TypeAnnotation(String()) ^(_): STRING()]] := true.
   	
   	[[ TypeAnnotation(Object(objectType)) ^ (s): ty ]] :=
   	  [[ objectType ^ (s) : ty ]].
    	
    [[ TypeAnnotation(Id(name)) ^ (s): ty ]] :=
    	Type{name} -> s,
    	Type{name} |-> d | error $[Cannot resolve [name]],
        d : ty.
    	
    [[ Lexical(_, declarations, _) ^ (s) ]] :=
    	Map1 [[ declarations ^ (s) ]].
    
    [[ Variable(declarations, _) ^ (s) ]] :=
      Map1 [[ declarations ^ (s) ]].
    
    [[ SimpleVariableDeclaration(name, None(), Some(value)) ^ (s) ]] := 
      [[ value ^ (s) : valueTy ]],
      Value{name} <- s,
      Value{name} : valueTy.

    [[ SimpleVariableDeclaration(name, Some(type), None()) ^ (s) ]] :=
    	Value{name} <- s,
    	Value{name} : ty !,
    	[[ type ^ (s) : ty ]].
    	
    [[ SimpleVariableDeclaration(name, Some(t@TypeAnnotation(Id(_))), Some(value)) ^ (s) ]] :=
      Value{name} <- s,
      Value{name} : ty !,
      [[ t ^ (s) : RECORD(type_scope) ]],
      [[ value ^ (s) : RECORD(value_scope) ]],
      D(type_scope)/Field subseteq/name D(value_scope)/Field | error $[Field [NAME] not initialized].

    [[ SimpleVariableDeclaration(name, Some(type), Some(value)) ^ (s) ]] :=
    	Value{name} <- s,
    	Value{name} : ty !,
    	[[ type ^ (s) : ty ]],
    	[[ value ^ (s) : valueTy ]],
    	ty <? valueTy.
    
    [[ Number(_) ^ (_): NUMBER() ]] := true.
    [[ String(_) ^ (_): STRING() ]] := true.
    [[ True() ^ (_): BOOLEAN() ]] := true.
    [[ False() ^ (_): BOOLEAN() ]] := true.
    
    [[ Expression(expression, _) ^ (s) ]] :=
      [[ expression ^ (s): ty ]].
    
    [[ Id(name) ^ (s) : ty ]] :=
      Value{name} -> s,
      Value{name} |-> d | error $[Cannot resolve [name]],
        d : ty.
    
    [[ Function(name, CallSignature(_, parameters, returnType), body) ^ (s) ]] :=
      new function_scope,
      [[ name ^ (s): FUNCTION(paramsTy, returnTy) ]],
      [[ parameters ^ (s, function_scope): paramsTy ]],
      [[ returnType ^ (s) : returnTy ]],
      Return{"function"} <- function_scope,
      Return{"function"} : returnTy,
      Map1 [[ body ^ (function_scope) ]].
    
    [[ FunctionName(name) ^ (s) : ty ]] :=
      Value{name} <- s,
      Value{name} : ty !.
    [[ NoName() ^ (_) : ty ]].
    
    [[ NoParameters() ^ (_) : [] ]].
    [[ Parameters(parameters) ^ (s, function_scope) : paramsTy ]] :=
      [[ parameters ^ (s, function_scope): paramsTy ]].
    
    [[ NoReturnType() ^ (_) : ty ]].
    [[ ReturnType(type) ^ (s) : returnTy ]] :=
      [[ type ^ (s): returnTy ]].
    
    [[ FunctionExpression(Function(_, CallSignature(_, parameters, returnType), body)) ^ (s): FUNCTION(paramsTy, returnTy) ]] :=
      new function_scope,
      [[ parameters ^ (s, function_scope): paramsTy ]],
      [[ returnType ^ (s) : returnTy ]],
      Return{"function"} <- function_scope,
      Return{"function"} : returnTy,
      Map1 [[ body ^ (function_scope) ]].
     
    [[ RequiredParameterList(parameters) ^ (s, function_scope) : ty ]] :=
      Map2T [[ parameters ^ (s, function_scope): ty ]].
    
    [[ RequiredParameter(name, None()) ^ (s, function_scope) : ty ]] := false.
     
    [[ RequiredParameter(name, Some(type)) ^ (s, function_scope) : ty ]] :=
      Value{name} <- function_scope,
      Value{name} : ty !,
      [[ type ^ (s) : ty ]].
    
    [[ If(condition, trueBlock) ^ (s) ]] :=
      [[ condition ^ (s) : valueTy ]],
      valueTy == BOOLEAN() | error $[Boolean expected, got [valueTy]],
      [[ trueBlock ^ (s) ]].
    
    [[ IfElse(condition, trueBlock, falseBlock) ^ (s) ]] :=
      [[ condition ^ (s) : valueTy ]],
      valueTy == BOOLEAN() | error $[Boolean expected, got [valueTy]],
      [[ trueBlock ^ (s) ]],
      [[ falseBlock ^ (s) ]].
    
    [[ Block(statements) ^ (s) ]] :=
      Map1 [[ statements ^ (s) ]].
    
    [[ ValueReturn(value, _) ^ (s) ]] :=
      [[ value ^ (s) : valueTy ]],
      Return{"function"} -> s,
      Return{"function"} |-> d | error $[Can not use return outside of a function scope],
      d: ty,
      ty == valueTy.
    
    [[ EmptyReturn() ^ (s) ]] :=
      Return{"function"} -> s,
      Return{"function"} |-> d | error $[Can not use return outside of a function scope],
      d: ty,
      ty == UNDEFINED().
    
    [[ Call(function, arguments) ^ (s) : ty ]] :=
      [[ function ^ (s) : functionTy ]],
      functionTy == FUNCTION(paramsTy, ty),
      Map1T [[ arguments ^ (s): argsTy ]],
      argsTy <? paramsTy.
    	
    [[ ObjectDecl(properties) ^ (s): ty ]] :=
      new record_scope,
      ty == RECORD(record_scope),
      Map2 [[ properties ^ (s, record_scope) ]],
      distinct/name D(record_scope)/Field | error $[Duplicate declaration of field] @ NAMES.
    
    [[ Property(name, value) ^ (s, record_scope) ]] :=
      [[ value ^ (s) : valueTy ]],
      Field{name} <- record_scope,
      Field{name} : valueTy !.
    
    [[ PropertyLookup(record, field) ^ (s) : ty ]] :=
      [[ record ^ (s) : recordTy ]],
      recordTy == RECORD(record_scope) | error $[Record expected, got $[recordTy]],
      new s_use,
      s_use -I-> record_scope,
      Field{field} -> s_use,
      Field{field} |-> d | error $[Can not find field $[field] in record $[record]],
      d: ty.   
    	
    	