module typescript

imports
  
  Common
 
template options

  tokenize: "(,[;{.="

context-free start-symbols
  
  PrimaryExpression Statement Program Declaration ObjectType

context-free syntax
 
  Program.program = Statement*
  
  Statement.variableStatement = VariableStatement
  Statement.declaration = Declaration
  Statement.return = ReturnStatement
  
  VariableStatement.variable = <var <{VariableDeclaration ","}+>;>
  
  Declaration.interfaceDeclaration = InterfaceDeclaration
  Declaration.hoistable = HoistableDeclaration
  Declaration.lexical = LexicalDeclaration
  
  HoistableDeclaration.function = FunctionDeclaration
  
  FunctionDeclaration.function = <
  function <BindingIdentifier?><CallSignature> {
    <FunctionBody>
  }
  >
  
  LexicalDeclaration.lexical = <<LetOrConst> <{VariableDeclaration ","}+>;>
  
  ReturnStatement.empty = <return;>
  ReturnStatement.value = <return <PrimaryExpression>;>
  
//  TODO
//  InterfaceDeclaration.interface = <interface <BindingIdentifier><TypeParameters?><InterfaceExtendsClause?><ObjectType>>
  InterfaceDeclaration.interface = <interface <BindingIdentifier><TypeParameters?><ObjectType>>
  
//  TODO
//  InterfaceExtendsClause.extends = <extends <{ ","}+>>

  PrimaryType.object = ObjectType
  
  ObjectType.object = <{<TypeBody?>}>
  
  TypeBody.semiColon = <<TypeMemberList><SemiColon?>>
  TypeBody.comma = <<TypeMemberList><Comma?>>
  
  TypeMemberList.typemember = TypeMember
  TypeMemberList.semiColon = <<TypeMemberList><SemiColon><TypeMember>>
  TypeMemberList.comma = <<TypeMemberList><Comma><TypeMember>>
  
  TypeMember.property = PropertySignature
  
  PropertySignature.property = <<LiteralPropertyName><QuestionMark?><TypeAnnotation?>>
  
  FunctionBody.statementList = StatementListItem*
  
  StatementListItem.statement = Statement
  StatementListItem.declaration = Declaration
  
  LetOrConst.letDeclaration = <let>
  LetOrConst.constDeclaration = <const>
  
  VariableDeclaration.simpleVariableDeclaration = <<BindingIdentifier> <TypeAnnotation?> <Initializer?>>
  
  TypeAnnotation.typeAnnotation = <: <Type>>
  
  BindingIdentifier.identifier = ID
  
  BindingIdentifierOrPattern.identifier = BindingIdentifier
//  TODO
//  BindingIdentifierOrPattern.pattern = BindingPattern
  
  CallSignature.callSignature = <<TypeParameters?>(<ParameterList?>)<TypeAnnotation?>>
  
  TypeParameters.typeParameters = <\<<{TypeParameter ","}+>\>>
 
  TypeParameter.typeParameter = <<BindingIdentifier> <Constraint?>>

  Constraint.constraint = <extends <Type>>
  
  ParameterList.requiredParameterList = {RequiredParameter ","}+
// TODO
//  OptionalParameterList
//   RestParameter
//   RequiredParameterList , OptionalParameterList
//   RequiredParameterList , RestParameter
//   OptionalParameterList , RestParameter
//   RequiredParameterList , OptionalParameterList , RestParameter
  
  RequiredParameter.requiredParameter = /*<AccessibilityModifier?>*/<<BindingIdentifierOrPattern> <TypeAnnotation?>>
  
  AccessibilityModifier.public = <public>
  AccessibilityModifier.private = <private>
  AccessibilityModifier.protected = <protected>
  
  Initializer.initializer = <= <PrimaryExpression>>
  
  PrimaryExpression.this = <this>
  PrimaryExpression.identifier = BindingIdentifier
  PrimaryExpression.literal = Literal
  PrimaryExpression.object = ObjectLiteral
  
  ObjectLiteral.empty = <{}>
  ObjectLiteral.fields = <{<{PropertyDefinition ","}+>}>
  ObjectLiteral.fieldsTrailingComma = <{<{PropertyDefinition ","}+>,}>
  
  PropertyDefinition.identifier = BindingIdentifier
  PropertyDefinition.property = <<PropertyName>: <PrimaryExpression>>
  
  PropertyName.literal = LiteralPropertyName
  PropertyName.computed = <[<PrimaryExpression>]>
  
  LiteralPropertyName.identifier = ID
  LiteralPropertyName.string = STRING
  LiteralPropertyName.number = NumericLiteral
  
//  PrimaryExpression.undefined = <undefined>
//  PrimaryExpression.binary = <<PrimaryExpression> <Operator> <PrimaryExpression>>
  
  Type.void = <void>
  Type.number = <number>
  Type.boolean = <boolean>
  Type.string = <string>
