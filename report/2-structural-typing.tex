\section{Structural Typing}
This section gives a high level overview of how structural type systems work and their motivation in TypeScript.
Structural subtyping stands oposed to nominal subtyping. 
Many of the top languages in use in industry today emply a nominal type system.
In such languages, subtype relationships are explicitly declared.
The programmer has to relate two types to each other by their name,
after which the compiler will check whether the structures refered to by these names are compatible.
This process has to be done only once for each declared subtype relation.
As soon as the compiler has established that a type A is a subtype of B,
the next time that a check for this relationship has to be performed, 
a simple table lookup for the two names is sufficient.
\\
\\
With structural subtyping on the other hand, the relationships between types are implicit.
The programmer does not have to specify any relationship by hand,
every time the compiler has to check compatibility between two types, a structural comparisson of the types is done.
One major consequence of this approach is that names for types become purely cosmetic.
The programmer can still assign names to types, and refer to those types by their names,
but checking whether one type is a subtype of another is completely dependent on their strucrure.
Generally this means that a type A is a subtype of B when the structure of A has at least as much information as the strucrure of B.
This means that a value of type A can be assigned to B by simply removing all information present in A that is not required by B.
For most languages that implement structural subtyping, the information that types carry consists of names paired with another type.
For example, in TypeScript we may write:

\begin{lstlisting}
type A = { first: string, second: string }
\end{lstlisting}



This defines the type A to be an object that contains tw named fields of type 'string'.
Values of type A can be passed to anywhere a subset of \texttt{\{ first: string, second: string \}} is required.
